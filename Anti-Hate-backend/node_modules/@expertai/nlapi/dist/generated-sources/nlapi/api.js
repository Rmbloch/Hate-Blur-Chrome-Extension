"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * expert.ai Natural Language API
 * Natural Language API provides a comprehensive set of natural language understanding capabilities based on expert.ai technology: <ul>   <li>Context based document analysis, comprising:</li>   <ul>     <li>Deep linguistic analysis, which, in turn, comprises:</li>     <ul>       <li>Text subdivision</li>       <li>Part-of-speech tagging</li>       <li>Morphological analysis</li>       <li>Lemmatization</li>       <li>Syntactic analysis</li>       <li>Semantic analysis</li>     </ul>     <li>Keyphrase extraction</li>     <li>Named entity recognition</li>     <li>Relation extraction</li>     <li>Sentiment analysis</li>   </ul>   <li>Taxonomy based document classification</li>   <li>Information detection performed by detectors</li> </ul>
 *
 * The version of the OpenAPI document: v2
 * Contact: api.inquiry@expert.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InformationDetectionApi = exports.InformationDetectionApiFactory = exports.InformationDetectionApiFp = exports.InformationDetectionApiAxiosParamCreator = exports.DocumentClassificationApi = exports.DocumentClassificationApiFactory = exports.DocumentClassificationApiFp = exports.DocumentClassificationApiAxiosParamCreator = exports.DocumentAnalysisApi = exports.DocumentAnalysisApiFactory = exports.DocumentAnalysisApiFp = exports.DocumentAnalysisApiAxiosParamCreator = exports.PointTypeEnum = exports.FeatureCollectionTypeEnum = exports.FeatureTypeEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var FeatureTypeEnum;
(function (FeatureTypeEnum) {
    FeatureTypeEnum["Feature"] = "Feature";
})(FeatureTypeEnum = exports.FeatureTypeEnum || (exports.FeatureTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var FeatureCollectionTypeEnum;
(function (FeatureCollectionTypeEnum) {
    FeatureCollectionTypeEnum["FeatureCollection"] = "FeatureCollection";
})(FeatureCollectionTypeEnum = exports.FeatureCollectionTypeEnum || (exports.FeatureCollectionTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PointTypeEnum;
(function (PointTypeEnum) {
    PointTypeEnum["Point"] = "Point";
})(PointTypeEnum = exports.PointTypeEnum || (exports.PointTypeEnum = {}));
/**
 * DocumentAnalysisApi - axios parameter creator
 * @export
 */
const DocumentAnalysisApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul>
         * @summary Specific partial analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguageAnalysisPost: (context, language, analysis, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'context' is not null or undefined
            (0, common_1.assertParamExists)('analyzeContextLanguageAnalysisPost', 'context', context);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('analyzeContextLanguageAnalysisPost', 'language', language);
            // verify required parameter 'analysis' is not null or undefined
            (0, common_1.assertParamExists)('analyzeContextLanguageAnalysisPost', 'analysis', analysis);
            const localVarPath = `/analyze/{context}/{language}/{analysis}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)))
                .replace(`{${"analysis"}}`, encodeURIComponent(String(analysis)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Full analysis (i.e., sum of all available partial analyses) of the posted text
         * @summary Full analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguagePost: (context, language, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'context' is not null or undefined
            (0, common_1.assertParamExists)('analyzeContextLanguagePost', 'context', context);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('analyzeContextLanguagePost', 'language', language);
            const localVarPath = `/analyze/{context}/{language}`
                .replace(`{${"context"}}`, encodeURIComponent(String(context)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Information about available contexts
         * @summary Contexts information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DocumentAnalysisApiAxiosParamCreator = DocumentAnalysisApiAxiosParamCreator;
/**
 * DocumentAnalysisApi - functional programming interface
 * @export
 */
const DocumentAnalysisApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DocumentAnalysisApiAxiosParamCreator)(configuration);
    return {
        /**
         * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul>
         * @summary Specific partial analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Full analysis (i.e., sum of all available partial analyses) of the posted text
         * @summary Full analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguagePost(context, language, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.analyzeContextLanguagePost(context, language, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Information about available contexts
         * @summary Contexts information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.contextsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.DocumentAnalysisApiFp = DocumentAnalysisApiFp;
/**
 * DocumentAnalysisApi - factory interface
 * @export
 */
const DocumentAnalysisApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DocumentAnalysisApiFp)(configuration);
    return {
        /**
         * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul>
         * @summary Specific partial analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options) {
            return localVarFp.analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Full analysis (i.e., sum of all available partial analyses) of the posted text
         * @summary Full analysis
         * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
         * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeContextLanguagePost(context, language, analysisRequest, options) {
            return localVarFp.analyzeContextLanguagePost(context, language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about available contexts
         * @summary Contexts information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsGet(options) {
            return localVarFp.contextsGet(options).then((request) => request(axios, basePath));
        },
    };
};
exports.DocumentAnalysisApiFactory = DocumentAnalysisApiFactory;
/**
 * DocumentAnalysisApi - object-oriented interface
 * @export
 * @class DocumentAnalysisApi
 * @extends {BaseAPI}
 */
class DocumentAnalysisApi extends base_1.BaseAPI {
    /**
     * Specific analysis of the posted text. Available analyses are: <ul>   <li><strong>disambiguation</strong>: linguistic analysis (text subdivision, part-of-speech tagging, morphological analysis, lemmatization, syntactic analysis and semantic analysis)</li>   <li><strong>relevants</strong>: keyphrase extraction</li>   <li><strong>entities</strong>: named entity recognition</li>   <li><strong>relations</strong>: relation extraction</li>   <li><strong>sentiment</strong>: sentiment analysis</li> </ul>
     * @summary Specific partial analysis
     * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
     * @param {'disambiguation' | 'relevants' | 'entities' | 'sentiment' | 'relations'} analysis Analysis name; use the &#x60;contexts&#x60; resource to determine if the context provides that analysis for the chosen language
     * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAnalysisApi
     */
    analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options) {
        return (0, exports.DocumentAnalysisApiFp)(this.configuration).analyzeContextLanguageAnalysisPost(context, language, analysis, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Full analysis (i.e., sum of all available partial analyses) of the posted text
     * @summary Full analysis
     * @param {string} context Context name; use the &#x60;contexts&#x60; resource to discover available contexts
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code)
     * @param {AnalysisRequest} [analysisRequest] The document to be analyzed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAnalysisApi
     */
    analyzeContextLanguagePost(context, language, analysisRequest, options) {
        return (0, exports.DocumentAnalysisApiFp)(this.configuration).analyzeContextLanguagePost(context, language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Information about available contexts
     * @summary Contexts information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentAnalysisApi
     */
    contextsGet(options) {
        return (0, exports.DocumentAnalysisApiFp)(this.configuration).contextsGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DocumentAnalysisApi = DocumentAnalysisApi;
/**
 * DocumentClassificationApi - axios parameter creator
 * @export
 */
const DocumentClassificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Classification of the posted text
         * @summary Emotional traits classification with extra data containing the main groups of emotions
         * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeEmotionalTraitsLanguagePost: (language, features, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('categorizeEmotionalTraitsLanguagePost', 'language', language);
            // verify required parameter 'features' is not null or undefined
            (0, common_1.assertParamExists)('categorizeEmotionalTraitsLanguagePost', 'features', features);
            const localVarPath = `/categorize/emotional-traits/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * GeoJSON classification of the posted text
         * @summary Classification
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeGeotaxLanguagePost: (language, features, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('categorizeGeotaxLanguagePost', 'language', language);
            // verify required parameter 'features' is not null or undefined
            (0, common_1.assertParamExists)('categorizeGeotaxLanguagePost', 'features', features);
            const localVarPath = `/categorize/geotax/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (features !== undefined) {
                localVarQueryParameter['features'] = features;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Classification of the posted text
         * @summary Classification
         * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeTaxonomyLanguagePost: (taxonomy, language, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'taxonomy' is not null or undefined
            (0, common_1.assertParamExists)('categorizeTaxonomyLanguagePost', 'taxonomy', taxonomy);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('categorizeTaxonomyLanguagePost', 'language', language);
            const localVarPath = `/categorize/{taxonomy}/{language}`
                .replace(`{${"taxonomy"}}`, encodeURIComponent(String(taxonomy)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Information about available taxonomies
         * @summary Taxonomies information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/taxonomies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detailed information about a taxonomy for a given language
         * @summary Taxonomy tree
         * @param {string} taxonomy Taxonomy name
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesTaxonomyLanguageGet: (taxonomy, language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'taxonomy' is not null or undefined
            (0, common_1.assertParamExists)('taxonomiesTaxonomyLanguageGet', 'taxonomy', taxonomy);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('taxonomiesTaxonomyLanguageGet', 'language', language);
            const localVarPath = `/taxonomies/{taxonomy}/{language}`
                .replace(`{${"taxonomy"}}`, encodeURIComponent(String(taxonomy)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DocumentClassificationApiAxiosParamCreator = DocumentClassificationApiAxiosParamCreator;
/**
 * DocumentClassificationApi - functional programming interface
 * @export
 */
const DocumentClassificationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DocumentClassificationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Classification of the posted text
         * @summary Emotional traits classification with extra data containing the main groups of emotions
         * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * GeoJSON classification of the posted text
         * @summary Classification
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeGeotaxLanguagePost(language, features, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categorizeGeotaxLanguagePost(language, features, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Classification of the posted text
         * @summary Classification
         * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Information about available taxonomies
         * @summary Taxonomies information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taxonomiesGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Detailed information about a taxonomy for a given language
         * @summary Taxonomy tree
         * @param {string} taxonomy Taxonomy name
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesTaxonomyLanguageGet(taxonomy, language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taxonomiesTaxonomyLanguageGet(taxonomy, language, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.DocumentClassificationApiFp = DocumentClassificationApiFp;
/**
 * DocumentClassificationApi - factory interface
 * @export
 */
const DocumentClassificationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DocumentClassificationApiFp)(configuration);
    return {
        /**
         * Classification of the posted text
         * @summary Emotional traits classification with extra data containing the main groups of emotions
         * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options) {
            return localVarFp.categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * GeoJSON classification of the posted text
         * @summary Classification
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
         * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeGeotaxLanguagePost(language, features, analysisRequest, options) {
            return localVarFp.categorizeGeotaxLanguagePost(language, features, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Classification of the posted text
         * @summary Classification
         * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
         * @param {AnalysisRequest} [analysisRequest] The document to be classified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options) {
            return localVarFp.categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about available taxonomies
         * @summary Taxonomies information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesGet(options) {
            return localVarFp.taxonomiesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Detailed information about a taxonomy for a given language
         * @summary Taxonomy tree
         * @param {string} taxonomy Taxonomy name
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taxonomiesTaxonomyLanguageGet(taxonomy, language, options) {
            return localVarFp.taxonomiesTaxonomyLanguageGet(taxonomy, language, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DocumentClassificationApiFactory = DocumentClassificationApiFactory;
/**
 * DocumentClassificationApi - object-oriented interface
 * @export
 * @class DocumentClassificationApi
 * @extends {BaseAPI}
 */
class DocumentClassificationApi extends base_1.BaseAPI {
    /**
     * Classification of the posted text
     * @summary Emotional traits classification with extra data containing the main groups of emotions
     * @param {'en' | 'de'} language Two letter ISO code of the input document language. Currently the &#x60;emotional-traits&#x60; taxonomy is available for the English language (language code &#x60;en&#x60;), support for more languages will be added in future releases.
     * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain main groups
     * @param {AnalysisRequest} [analysisRequest] The document to be classified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options) {
        return (0, exports.DocumentClassificationApiFp)(this.configuration).categorizeEmotionalTraitsLanguagePost(language, features, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * GeoJSON classification of the posted text
     * @summary Classification
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource of the expert.ai Natural Language API to discover the languages that the classification module supports
     * @param {'extradata'} features Classification features, specify &#x60;extradata&#x60; to obtain GeoJSON data
     * @param {AnalysisRequest} [analysisRequest] The document to be classified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    categorizeGeotaxLanguagePost(language, features, analysisRequest, options) {
        return (0, exports.DocumentClassificationApiFp)(this.configuration).categorizeGeotaxLanguagePost(language, features, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Classification of the posted text
     * @summary Classification
     * @param {string} taxonomy Taxonomy name; use the &#x60;taxonomies&#x60; resource to discover available taxonomies
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;taxonomies&#x60; resource to discover the languages for which the taxonomy is available
     * @param {AnalysisRequest} [analysisRequest] The document to be classified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options) {
        return (0, exports.DocumentClassificationApiFp)(this.configuration).categorizeTaxonomyLanguagePost(taxonomy, language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Information about available taxonomies
     * @summary Taxonomies information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    taxonomiesGet(options) {
        return (0, exports.DocumentClassificationApiFp)(this.configuration).taxonomiesGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detailed information about a taxonomy for a given language
     * @summary Taxonomy tree
     * @param {string} taxonomy Taxonomy name
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Taxonomy language (code); use the &#x60;taxonomies&#x60; resource to discover the languages that the taxonomy supports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentClassificationApi
     */
    taxonomiesTaxonomyLanguageGet(taxonomy, language, options) {
        return (0, exports.DocumentClassificationApiFp)(this.configuration).taxonomiesTaxonomyLanguageGet(taxonomy, language, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DocumentClassificationApi = DocumentClassificationApi;
/**
 * InformationDetectionApi - axios parameter creator
 * @export
 */
const InformationDetectionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Information detection on the posted text
         * @summary Information detection
         * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
         * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectDetectorLanguagePost: (detector, language, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'detector' is not null or undefined
            (0, common_1.assertParamExists)('detectDetectorLanguagePost', 'detector', detector);
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('detectDetectorLanguagePost', 'language', language);
            const localVarPath = `/detect/{detector}/{language}`
                .replace(`{${"detector"}}`, encodeURIComponent(String(detector)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary PII detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectPiiLanguagePost: (language, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('detectPiiLanguagePost', 'language', language);
            const localVarPath = `/detect/pii/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Temporal information detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectTemporalInformationLanguagePost: (language, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('detectTemporalInformationLanguagePost', 'language', language);
            const localVarPath = `/detect/temporal-information/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Writeprint detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectWriteprintLanguagePost: (language, analysisRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'language' is not null or undefined
            (0, common_1.assertParamExists)('detectWriteprintLanguagePost', 'language', language);
            const localVarPath = `/detect/writeprint/{language}`
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(analysisRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Information about available detectors
         * @summary Detectors information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectorsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/detectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InformationDetectionApiAxiosParamCreator = InformationDetectionApiAxiosParamCreator;
/**
 * InformationDetectionApi - functional programming interface
 * @export
 */
const InformationDetectionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InformationDetectionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Information detection on the posted text
         * @summary Information detection
         * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
         * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectDetectorLanguagePost(detector, language, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detectDetectorLanguagePost(detector, language, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary PII detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectPiiLanguagePost(language, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detectPiiLanguagePost(language, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Temporal information detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectTemporalInformationLanguagePost(language, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detectTemporalInformationLanguagePost(language, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Writeprint detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectWriteprintLanguagePost(language, analysisRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detectWriteprintLanguagePost(language, analysisRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Information about available detectors
         * @summary Detectors information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectorsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.detectorsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InformationDetectionApiFp = InformationDetectionApiFp;
/**
 * InformationDetectionApi - factory interface
 * @export
 */
const InformationDetectionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InformationDetectionApiFp)(configuration);
    return {
        /**
         * Information detection on the posted text
         * @summary Information detection
         * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
         * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
         * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectDetectorLanguagePost(detector, language, analysisRequest, options) {
            return localVarFp.detectDetectorLanguagePost(detector, language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary PII detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectPiiLanguagePost(language, analysisRequest, options) {
            return localVarFp.detectPiiLanguagePost(language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Temporal information detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectTemporalInformationLanguagePost(language, analysisRequest, options) {
            return localVarFp.detectTemporalInformationLanguagePost(language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Writeprint detection
         * @param {string} language
         * @param {AnalysisRequest} [analysisRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectWriteprintLanguagePost(language, analysisRequest, options) {
            return localVarFp.detectWriteprintLanguagePost(language, analysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Information about available detectors
         * @summary Detectors information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detectorsGet(options) {
            return localVarFp.detectorsGet(options).then((request) => request(axios, basePath));
        },
    };
};
exports.InformationDetectionApiFactory = InformationDetectionApiFactory;
/**
 * InformationDetectionApi - object-oriented interface
 * @export
 * @class InformationDetectionApi
 * @extends {BaseAPI}
 */
class InformationDetectionApi extends base_1.BaseAPI {
    /**
     * Information detection on the posted text
     * @summary Information detection
     * @param {string} detector Detector name; use the &#x60;detectors&#x60; resource to discover available detectors
     * @param {'de' | 'en' | 'es' | 'fr' | 'it'} language Document language (code); use the &#x60;detectors&#x60; resource to discover the languages for which the detector is available
     * @param {AnalysisRequest} [analysisRequest] The document on which to perform information detection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    detectDetectorLanguagePost(detector, language, analysisRequest, options) {
        return (0, exports.InformationDetectionApiFp)(this.configuration).detectDetectorLanguagePost(detector, language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary PII detection
     * @param {string} language
     * @param {AnalysisRequest} [analysisRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    detectPiiLanguagePost(language, analysisRequest, options) {
        return (0, exports.InformationDetectionApiFp)(this.configuration).detectPiiLanguagePost(language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Temporal information detection
     * @param {string} language
     * @param {AnalysisRequest} [analysisRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    detectTemporalInformationLanguagePost(language, analysisRequest, options) {
        return (0, exports.InformationDetectionApiFp)(this.configuration).detectTemporalInformationLanguagePost(language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Writeprint detection
     * @param {string} language
     * @param {AnalysisRequest} [analysisRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    detectWriteprintLanguagePost(language, analysisRequest, options) {
        return (0, exports.InformationDetectionApiFp)(this.configuration).detectWriteprintLanguagePost(language, analysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Information about available detectors
     * @summary Detectors information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationDetectionApi
     */
    detectorsGet(options) {
        return (0, exports.InformationDetectionApiFp)(this.configuration).detectorsGet(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InformationDetectionApi = InformationDetectionApi;
//# sourceMappingURL=api.js.map